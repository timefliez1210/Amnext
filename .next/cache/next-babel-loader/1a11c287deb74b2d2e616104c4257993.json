{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\n\nvar _s = $RefreshSig$();\n\nimport { useState, useEffect, useCallback, useRef } from \"react\"; // Fetching WEB3 Provider\n\nexport var loadWeb3 = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!window.ethereum) {\n              _context.next = 6;\n              break;\n            }\n\n            window.web3 = new Web3(window.ethereum);\n            _context.next = 4;\n            return window.ethereum.enable();\n\n          case 4:\n            _context.next = 7;\n            break;\n\n          case 6:\n            if (window.web3) {\n              window.web3 = new Web3(window.web3.currentProvider);\n            } else {\n              window.alert(\"Non-Ethereum browser detected. You should consider trying MetaMask!\");\n            }\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function loadWeb3() {\n    return _ref.apply(this, arguments);\n  };\n}(); // Async setState\n\nexport var useStateWithPromise = function useStateWithPromise(initialState) {\n  _s();\n\n  var _useState = useState(initialState),\n      state = _useState[0],\n      setState = _useState[1];\n\n  var resolverRef = useRef(null);\n  useEffect(function () {\n    if (resolverRef.current) {\n      resolverRef.current(state);\n      resolverRef.current = null;\n    }\n    /**\r\n     * Since a state update could be triggered with the exact same state again,\r\n     * it's not enough to specify state as the only dependency of this useEffect.\r\n     * That's why resolverRef.current is also a dependency, because it will guarantee,\r\n     * that handleSetState was called in previous render\r\n     */\n\n  }, [resolverRef.current, state]);\n  var handleSetState = useCallback(function (stateAction) {\n    setState(stateAction);\n    return new Promise(function (resolve) {\n      resolverRef.current = resolve;\n    });\n  }, [setState]);\n  return [state, handleSetState];\n};\n\n_s(useStateWithPromise, \"EUMSdK+jLdICJIaWW9bEXx6tPAg=\");","map":{"version":3,"sources":["C:/Users/crfab/Desktop/forsage-boilerplate/utils/utility.js"],"names":["useState","useEffect","useCallback","useRef","loadWeb3","window","ethereum","web3","Web3","enable","currentProvider","alert","useStateWithPromise","initialState","state","setState","resolverRef","current","handleSetState","stateAction","Promise","resolve"],"mappings":";;;;;AAAA,SAASA,QAAT,EAAmBC,SAAnB,EAA8BC,WAA9B,EAA2CC,MAA3C,QAAyD,OAAzD,C,CAEA;;AAEA,OAAO,IAAMC,QAAQ;AAAA,sEAAG;AAAA;AAAA;AAAA;AAAA;AAAA,iBAClBC,MAAM,CAACC,QADW;AAAA;AAAA;AAAA;;AAEpBD,YAAAA,MAAM,CAACE,IAAP,GAAc,IAAIC,IAAJ,CAASH,MAAM,CAACC,QAAhB,CAAd;AAFoB;AAAA,mBAGdD,MAAM,CAACC,QAAP,CAAgBG,MAAhB,EAHc;;AAAA;AAAA;AAAA;;AAAA;AAIf,gBAAIJ,MAAM,CAACE,IAAX,EAAiB;AACtBF,cAAAA,MAAM,CAACE,IAAP,GAAc,IAAIC,IAAJ,CAASH,MAAM,CAACE,IAAP,CAAYG,eAArB,CAAd;AACD,aAFM,MAEA;AACLL,cAAAA,MAAM,CAACM,KAAP,CACE,qEADF;AAGD;;AAVqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA,kBAARP,QAAQ;AAAA;AAAA;AAAA,GAAd,C,CAaP;;AAEA,OAAO,IAAMQ,mBAAmB,GAAG,SAAtBA,mBAAsB,CAACC,YAAD,EAAkB;AAAA;;AAAA,kBACzBb,QAAQ,CAACa,YAAD,CADiB;AAAA,MAC5CC,KAD4C;AAAA,MACrCC,QADqC;;AAEnD,MAAMC,WAAW,GAAGb,MAAM,CAAC,IAAD,CAA1B;AAEAF,EAAAA,SAAS,CAAC,YAAM;AACd,QAAIe,WAAW,CAACC,OAAhB,EAAyB;AACvBD,MAAAA,WAAW,CAACC,OAAZ,CAAoBH,KAApB;AACAE,MAAAA,WAAW,CAACC,OAAZ,GAAsB,IAAtB;AACD;AACD;;;;;;;AAMD,GAXQ,EAWN,CAACD,WAAW,CAACC,OAAb,EAAsBH,KAAtB,CAXM,CAAT;AAaA,MAAMI,cAAc,GAAGhB,WAAW,CAChC,UAACiB,WAAD,EAAiB;AACfJ,IAAAA,QAAQ,CAACI,WAAD,CAAR;AACA,WAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAa;AAC9BL,MAAAA,WAAW,CAACC,OAAZ,GAAsBI,OAAtB;AACD,KAFM,CAAP;AAGD,GAN+B,EAOhC,CAACN,QAAD,CAPgC,CAAlC;AAUA,SAAO,CAACD,KAAD,EAAQI,cAAR,CAAP;AACD,CA5BM;;GAAMN,mB","sourcesContent":["import { useState, useEffect, useCallback, useRef } from \"react\";\r\n\r\n// Fetching WEB3 Provider\r\n\r\nexport const loadWeb3 = async () => {\r\n  if (window.ethereum) {\r\n    window.web3 = new Web3(window.ethereum);\r\n    await window.ethereum.enable();\r\n  } else if (window.web3) {\r\n    window.web3 = new Web3(window.web3.currentProvider);\r\n  } else {\r\n    window.alert(\r\n      \"Non-Ethereum browser detected. You should consider trying MetaMask!\"\r\n    );\r\n  }\r\n};\r\n\r\n// Async setState\r\n\r\nexport const useStateWithPromise = (initialState) => {\r\n  const [state, setState] = useState(initialState);\r\n  const resolverRef = useRef(null);\r\n\r\n  useEffect(() => {\r\n    if (resolverRef.current) {\r\n      resolverRef.current(state);\r\n      resolverRef.current = null;\r\n    }\r\n    /**\r\n     * Since a state update could be triggered with the exact same state again,\r\n     * it's not enough to specify state as the only dependency of this useEffect.\r\n     * That's why resolverRef.current is also a dependency, because it will guarantee,\r\n     * that handleSetState was called in previous render\r\n     */\r\n  }, [resolverRef.current, state]);\r\n\r\n  const handleSetState = useCallback(\r\n    (stateAction) => {\r\n      setState(stateAction);\r\n      return new Promise((resolve) => {\r\n        resolverRef.current = resolve;\r\n      });\r\n    },\r\n    [setState]\r\n  );\r\n\r\n  return [state, handleSetState];\r\n};\r\n"]},"metadata":{},"sourceType":"module"}