{"ast":null,"code":"import { useState, useEffect, useCallback } from \"react\"; // Fetching WEB3 Provider\n\nexport const loadWeb3 = async () => {\n  if (window.ethereum) {\n    window.web3 = new Web3(window.ethereum);\n    await window.ethereum.enable();\n  } else if (window.web3) {\n    window.web3 = new Web3(window.web3.currentProvider);\n  } else {\n    window.alert(\"Non-Ethereum browser detected. You should consider trying MetaMask!\");\n  }\n}; // Async setState\n\nexport const useStateWithPromise = initialState => {\n  const {\n    0: state,\n    1: setState\n  } = useState(initialState);\n  const resolverRef = useRef(null);\n  useEffect(() => {\n    if (resolverRef.current) {\n      resolverRef.current(state);\n      resolverRef.current = null;\n    }\n    /**\r\n     * Since a state update could be triggered with the exact same state again,\r\n     * it's not enough to specify state as the only dependency of this useEffect.\r\n     * That's why resolverRef.current is also a dependency, because it will guarantee,\r\n     * that handleSetState was called in previous render\r\n     */\n\n  }, [resolverRef.current, state]);\n  const handleSetState = useCallback(stateAction => {\n    setState(stateAction);\n    return new Promise(resolve => {\n      resolverRef.current = resolve;\n    });\n  }, [setState]);\n  return [state, handleSetState];\n};","map":{"version":3,"sources":["C:/Users/crfab/Desktop/forsage-boilerplate/utils/utility.js"],"names":["useState","useEffect","useCallback","loadWeb3","window","ethereum","web3","Web3","enable","currentProvider","alert","useStateWithPromise","initialState","state","setState","resolverRef","useRef","current","handleSetState","stateAction","Promise","resolve"],"mappings":"AAAA,SAASA,QAAT,EAAmBC,SAAnB,EAA8BC,WAA9B,QAAiD,OAAjD,C,CAEA;;AAEA,OAAO,MAAMC,QAAQ,GAAG,YAAY;AAClC,MAAIC,MAAM,CAACC,QAAX,EAAqB;AACnBD,IAAAA,MAAM,CAACE,IAAP,GAAc,IAAIC,IAAJ,CAASH,MAAM,CAACC,QAAhB,CAAd;AACA,UAAMD,MAAM,CAACC,QAAP,CAAgBG,MAAhB,EAAN;AACD,GAHD,MAGO,IAAIJ,MAAM,CAACE,IAAX,EAAiB;AACtBF,IAAAA,MAAM,CAACE,IAAP,GAAc,IAAIC,IAAJ,CAASH,MAAM,CAACE,IAAP,CAAYG,eAArB,CAAd;AACD,GAFM,MAEA;AACLL,IAAAA,MAAM,CAACM,KAAP,CACE,qEADF;AAGD;AACF,CAXM,C,CAaP;;AAEA,OAAO,MAAMC,mBAAmB,GAAIC,YAAD,IAAkB;AACnD,QAAM;AAAA,OAACC,KAAD;AAAA,OAAQC;AAAR,MAAoBd,QAAQ,CAACY,YAAD,CAAlC;AACA,QAAMG,WAAW,GAAGC,MAAM,CAAC,IAAD,CAA1B;AAEAf,EAAAA,SAAS,CAAC,MAAM;AACd,QAAIc,WAAW,CAACE,OAAhB,EAAyB;AACvBF,MAAAA,WAAW,CAACE,OAAZ,CAAoBJ,KAApB;AACAE,MAAAA,WAAW,CAACE,OAAZ,GAAsB,IAAtB;AACD;AACD;;;;;;;AAMD,GAXQ,EAWN,CAACF,WAAW,CAACE,OAAb,EAAsBJ,KAAtB,CAXM,CAAT;AAaA,QAAMK,cAAc,GAAGhB,WAAW,CAC/BiB,WAAD,IAAiB;AACfL,IAAAA,QAAQ,CAACK,WAAD,CAAR;AACA,WAAO,IAAIC,OAAJ,CAAaC,OAAD,IAAa;AAC9BN,MAAAA,WAAW,CAACE,OAAZ,GAAsBI,OAAtB;AACD,KAFM,CAAP;AAGD,GAN+B,EAOhC,CAACP,QAAD,CAPgC,CAAlC;AAUA,SAAO,CAACD,KAAD,EAAQK,cAAR,CAAP;AACD,CA5BM","sourcesContent":["import { useState, useEffect, useCallback } from \"react\";\r\n\r\n// Fetching WEB3 Provider\r\n\r\nexport const loadWeb3 = async () => {\r\n  if (window.ethereum) {\r\n    window.web3 = new Web3(window.ethereum);\r\n    await window.ethereum.enable();\r\n  } else if (window.web3) {\r\n    window.web3 = new Web3(window.web3.currentProvider);\r\n  } else {\r\n    window.alert(\r\n      \"Non-Ethereum browser detected. You should consider trying MetaMask!\"\r\n    );\r\n  }\r\n};\r\n\r\n// Async setState\r\n\r\nexport const useStateWithPromise = (initialState) => {\r\n  const [state, setState] = useState(initialState);\r\n  const resolverRef = useRef(null);\r\n\r\n  useEffect(() => {\r\n    if (resolverRef.current) {\r\n      resolverRef.current(state);\r\n      resolverRef.current = null;\r\n    }\r\n    /**\r\n     * Since a state update could be triggered with the exact same state again,\r\n     * it's not enough to specify state as the only dependency of this useEffect.\r\n     * That's why resolverRef.current is also a dependency, because it will guarantee,\r\n     * that handleSetState was called in previous render\r\n     */\r\n  }, [resolverRef.current, state]);\r\n\r\n  const handleSetState = useCallback(\r\n    (stateAction) => {\r\n      setState(stateAction);\r\n      return new Promise((resolve) => {\r\n        resolverRef.current = resolve;\r\n      });\r\n    },\r\n    [setState]\r\n  );\r\n\r\n  return [state, handleSetState];\r\n};\r\n"]},"metadata":{},"sourceType":"module"}